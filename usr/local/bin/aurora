#!/bin/bash

# ============================================================================
# AURORA - Gerenciador de Temas Visuais Avan√ßado
# Vers√£o: 2.0
# Autor: Kilo Code
# Descri√ß√£o: Interface de terminal responsiva com s√≠mbolos especiais
# Paleta: Ganache (tons de chocolate)
# ============================================================================

set -euo pipefail

# ============================================================================
# CONFIGURA√á√ïES GLOBAIS
# ============================================================================

SCRIPT_NAME="aurora"
SCRIPT_VERSION="2.0"
THEME_DIR="/etc/aurora/themes"
CONFIG_DIR="/etc/aurora"
KMSCON_CONF="/etc/kmscon/kmscon.conf"
STARSHIP_CONFIG="$HOME/.config/starship.toml"
BASHRC="$HOME/.bashrc"

# Paleta de Cores Ganache
DARK_COLORS=("#6a4928" "#5f4224" "#553a20" "#4a331c" "#402c18" "#352514" "#2a1d10" "#20160c" "#150f08" "#0b0704")
LIGHT_COLORS=("#ae998b" "#beada2" "#cec2b9" "#ded6d1" "#efebe8")

# ============================================================================
# COLE√á√ÉO COMPLETA DE S√çMBOLOS ESPECIAIS
# ============================================================================

# Caracteres de conex√£o avan√ßados
declare -A BOX_CHARS
BOX_CHARS[light_tl]="‚ï≠"
BOX_CHARS[light_tr]="‚ïÆ"
BOX_CHARS[light_bl]="‚ï∞"
BOX_CHARS[light_br]="‚ïØ"
BOX_CHARS[light_h]="‚îÄ"
BOX_CHARS[light_v]="‚îÇ"
BOX_CHARS[light_mid_t]="‚î¨"
BOX_CHARS[light_mid_b]="‚î¥"
BOX_CHARS[light_mid_l]="‚îú"
BOX_CHARS[light_mid_r]="‚î§"
BOX_CHARS[light_cross]="‚îº"

BOX_CHARS[heavy_tl]="‚îè"
BOX_CHARS[heavy_tr]="‚îì"
BOX_CHARS[heavy_bl]="‚îó"
BOX_CHARS[heavy_br]="‚îõ"
BOX_CHARS[heavy_h]="‚îÅ"
BOX_CHARS[heavy_v]="‚îÉ"
BOX_CHARS[heavy_mid_t]="‚î≥"
BOX_CHARS[heavy_mid_b]="‚îª"
BOX_CHARS[heavy_mid_l]="‚î£"
BOX_CHARS[heavy_mid_r]="‚î´"
BOX_CHARS[heavy_cross]="‚ïã"

BOX_CHARS[dotted_tl]="‚îå"
BOX_CHARS[dotted_tr]="‚îê"
BOX_CHARS[dotted_bl]="‚îî"
BOX_CHARS[dotted_br]="‚îò"
BOX_CHARS[dotted_h]="‚îÑ"
BOX_CHARS[dotted_v]="‚îÜ"
BOX_CHARS[dotted_mid_t]="‚î¨"
BOX_CHARS[dotted_mid_b]="‚î¥"
BOX_CHARS[dotted_mid_l]="‚îú"
BOX_CHARS[dotted_mid_r]="‚î§"
BOX_CHARS[dotted_cross]="‚îº"

# S√≠mbolos decorativos
declare -A DECORATIVE
DECORATIVE[star_filled]="‚òÖ"
DECORATIVE[star_outlined]="‚òÜ"
DECORATIVE[diamond_filled]="‚ô¶"
DECORATIVE[diamond_outlined]="‚óá"
DECORATIVE[heart_filled]="‚ô•"
DECORATIVE[heart_outlined]="‚ô°"
DECORATIVE[spade]="‚ô†"
DECORATIVE[club]="‚ô£"
DECORATIVE[circle_filled]="‚óè"
DECORATIVE[circle_outlined]="‚óã"
DECORATIVE[square_filled]="‚ñ†"
DECORATIVE[square_outlined]="‚ñ°"
DECORATIVE[triangle_filled]="‚ñ≤"
DECORATIVE[triangle_outlined]="‚ñ≥"

# Setas e indicadores
declare -A ARROWS
ARROWS[right]="‚Üí"
ARROWS[left]="‚Üê"
ARROWS[up]="‚Üë"
ARROWS[down]="‚Üì"
ARROWS[up_right]="‚Üó"
ARROWS[down_right]="‚Üò"
ARROWS[up_left]="‚Üñ"
ARROWS[down_left]="‚Üô"
ARROWS[double_right]="‚áí"
ARROWS[double_left]="‚áê"
ARROWS[double_up]="‚áë"
ARROWS[double_down]="‚áì"

# Elementos art√≠sticos
declare -A ARTISTIC
ARTISTIC[sparkle]="‚ú¶"
ARTISTIC[big_sparkle]="‚úß"
ARTISTIC[asterisk]="‚ú±"
ARTISTIC[flower]="‚ùÄ"
ARTISTIC[snowflake]="‚ùÑ"
ARTISTIC[cross]="‚úö"
ARTISTIC[plus]="‚úú"
ARTISTIC[circle_x]="‚úñ"
ARTISTIC[circle_plus]="‚úô"
ARTISTIC[star_circle]="‚ú™"
ARTISTIC[flower_circle]="‚ú©"
ARTISTIC[moon]="‚òΩ"
ARTISTIC[sun]="‚òÄ"
ARTISTIC[cloud]="‚òÅ"
ARTISTIC[umbrella]="‚òÇ"
ARTISTIC[snowman]="‚òÉ"

# Indicadores de status
declare -A STATUS
STATUS[success]="‚úì"
STATUS[error]="‚úó"
STATUS[warning]="‚ö†"
STATUS[info]="‚Ñπ"
STATUS[loading]="‚è≥"
STATUS[progress]="‚óê"
STATUS[check]="‚òë"
STATUS[cross]="‚òí"
STATUS[dot]="‚Ä¢"
STATUS[arrow_right]="‚ûú"
STATUS[arrow_left]="‚áê"

# ============================================================================
# SISTEMA DE LAYOUTS RESPONSIVOS
# ============================================================================

# Detectar largura e altura do terminal
get_terminal_dimensions() {
    local cols=$(tput cols 2>/dev/null || echo "80")
    local lines=$(tput lines 2>/dev/null || echo "24")
    echo "$cols $lines"
}

# Calcular layout din√¢mico baseado no terminal
calculate_layout() {
    local cols=$(get_terminal_dimensions | cut -d' ' -f1)
    
    # Definir layouts baseados na largura
    if (( cols >= 120 )); then
        echo "ultra_wide"
    elif (( cols >= 100 )); then
        echo "wide"
    elif (( cols >= 80 )); then
        echo "standard"
    elif (( cols >= 60 )); then
        echo "narrow"
    elif (( cols >= 40 )); then
        echo "minimal"
    else
        echo "tiny"
    fi
}

# ============================================================================
# SISTEMA DE CAIXAS INTELIGENTES
# ============================================================================

# Fun√ß√£o auxiliar: calcula a largura visual de uma string considerando Unicode
# Usa wc -L que calcula corretamente a largura de display em terminais modernos
get_visual_width() {
    local str="$1"

    # wc -L retorna a largura visual m√°xima da linha
    # Isso j√° considera caracteres de largura dupla em terminais com suporte UTF-8
    printf '%s' "$str" | wc -L
}

# Fun√ß√£o auxiliar: quebra texto em linhas respeitando largura visual
wrap_text_visual() {
    local text="$1"
    local max_width="$2"
    local lines=()
    local current_line=""
    local current_width=0

    # Primeiro, processar quebras de linha expl√≠citas
    while IFS= read -r paragraph || [[ -n "$paragraph" ]]; do
        # Se par√°grafo vazio, adicionar linha vazia
        if [[ -z "$paragraph" ]]; then
            if [[ -n "$current_line" ]]; then
                lines+=("$current_line")
                current_line=""
                current_width=0
            fi
            lines+=("")
            continue
        fi

        # Processar palavras do par√°grafo
        local words=()
        read -ra words <<< "$paragraph"

        for word in "${words[@]}"; do
            local word_width
            word_width=$(get_visual_width "$word")

            if (( current_width == 0 )); then
                # Primeira palavra da linha
                current_line="$word"
                current_width=$word_width
            elif (( current_width + 1 + word_width <= max_width )); then
                # Palavra cabe na linha atual
                current_line="$current_line $word"
                current_width=$((current_width + 1 + word_width))
            else
                # Palavra n√£o cabe, iniciar nova linha
                lines+=("$current_line")
                current_line="$word"
                current_width=$word_width
            fi
        done
    done <<< "$text"

    # Adicionar √∫ltima linha se houver
    if [[ -n "$current_line" ]]; then
        lines+=("$current_line")
    fi

    # Retornar linhas separadas por newline
    printf '%s\n' "${lines[@]}"
}

# Fun√ß√£o para criar caixa com estilo personaliz√°vel (Vers√£o Corrigida)
create_fancy_box() {
    local title="$1"
    local content="$2"
    local style="${3:-light}"
    local border_color="${4:-106;73;40}"
    local fill_color="${5:-190;173;162}"
    local width="${6:-auto}"

    # Obter dimens√µes do terminal
    local cols
    cols=$(get_terminal_dimensions | cut -d' ' -f1)

    # Calcular largura da caixa
    if [[ "$width" == "auto" ]]; then
        width=$((cols - 4))

        # L√≥gica de Largura Segura:
        # S√≥ for√ßa o m√≠nimo de 50 se o terminal tiver espa√ßo
        if (( width < 50 )); then
            if (( cols >= 54 )); then
                width=50
            fi
        fi

        # Limite m√°ximo para monitores ultrawide
        ((width > 90)) && width=90
    fi

    # Prote√ß√£o de conte√∫do vazio
    if [[ -z "$content" ]]; then content=" "; fi

    # ===============================================
    # C√ÅLCULOS DE LARGURA CORRIGIDOS
    # ===============================================
    # Largura total da caixa = width
    # Espa√ßo interno (entre bordas verticais) = width - 2
    # Margem esquerda para conte√∫do = 1
    # Largura m√°xima do texto de conte√∫do = width - 2 - 1 = width - 3

    local box_inner_width=$((width - 2))
    local content_text_width=$((box_inner_width - 1))  # Descontando margem esquerda de 1

    # Processar conte√∫do: converter \n literal para newline real e fazer wrap
    local processed_content
    processed_content=$(echo -e "$content")

    # Aplicar word-wrap visual com largura correta
    local wrapped_content
    wrapped_content=$(wrap_text_visual "$processed_content" "$content_text_width")

    # Converter para array de linhas
    local content_lines=()
    while IFS= read -r line; do
        content_lines+=("$line")
    done <<< "$wrapped_content"

    # Obter caracteres do estilo
    local tl="${BOX_CHARS[${style}_tl]}"
    local tr="${BOX_CHARS[${style}_tr]}"
    local bl="${BOX_CHARS[${style}_bl]}"
    local br="${BOX_CHARS[${style}_br]}"
    local h="${BOX_CHARS[${style}_h]}"
    local v="${BOX_CHARS[${style}_v]}"
    local mid_l="${BOX_CHARS[${style}_mid_l]}"
    local mid_r="${BOX_CHARS[${style}_mid_r]}"

    # Gerar linhas horizontais (box_inner_width caracteres)
    local horizontal_line
    horizontal_line=$(printf "%.0s$h" $(seq 1 "$box_inner_width"))

    # ===============================================
    # T√çTULO (centralizado, ocupa todo box_inner_width)
    # ===============================================
    local title_visual_width
    title_visual_width=$(get_visual_width "$title")
    local max_title_len=$((box_inner_width - 2))  # Deixar pelo menos 1 espa√ßo de cada lado

    # Truncar t√≠tulo se necess√°rio
    if (( title_visual_width > max_title_len )); then
        local truncated=""
        local char_count=0
        local i=0
        local len=${#title}

        while (( i < len && char_count < max_title_len - 1 )); do
            local char="${title:i:1}"
            local byte
            byte=$(printf '%d' "'$char" 2>/dev/null || echo 0)
            local char_width=1

            if (( byte >= 240 )); then
                char="${title:i:4}"
                char_width=2
                i=$((i + 4))
            elif (( byte >= 224 )); then
                char="${title:i:3}"
                char_width=1
                i=$((i + 3))
            elif (( byte >= 192 )); then
                char="${title:i:2}"
                i=$((i + 2))
            else
                i=$((i + 1))
            fi

            if (( char_count + char_width <= max_title_len - 1 )); then
                truncated+="$char"
                char_count=$((char_count + char_width))
            else
                break
            fi
        done
        title="${truncated}‚Ä¶"
        title_visual_width=$(get_visual_width "$title")
    fi

    # C√°lculo do padding do t√≠tulo para centraliza√ß√£o
    local title_left_pad=$(( (box_inner_width - title_visual_width) / 2 ))
    local title_right_pad=$((box_inner_width - title_visual_width - title_left_pad))
    (( title_left_pad < 0 )) && title_left_pad=0
    (( title_right_pad < 0 )) && title_right_pad=0

    # ===============================================
    # RENDERIZA√á√ÉO
    # ===============================================

    # Linha de topo
    echo -e "\033[38;2;${border_color}m${tl}${horizontal_line}${tr}\033[0m"

    # T√≠tulo (centralizado)
    echo -e "\033[38;2;${border_color}m${v}\033[0m\033[38;2;${fill_color}m$(printf "%*s" "$title_left_pad" "")${title}$(printf "%*s" "$title_right_pad" "")\033[38;2;${border_color}m${v}\033[0m"

    # Divisor
    echo -e "\033[38;2;${border_color}m${mid_l}${horizontal_line}${mid_r}\033[0m"

    # Conte√∫do (alinhado √† esquerda com margem de 1)
    for line in "${content_lines[@]}"; do
        local line_visual_width
        line_visual_width=$(get_visual_width "$line")

        # Margem esquerda = 1 espa√ßo
        # Padding direito = box_inner_width - 1 - line_visual_width
        local right_pad=$((box_inner_width - 1 - line_visual_width))
        (( right_pad < 0 )) && right_pad=0

        # Renderizar linha de conte√∫do
        echo -e "\033[38;2;${border_color}m${v}\033[0m\033[38;2;${fill_color}m $(printf "%s%*s" "$line" "$right_pad" "")\033[38;2;${border_color}m${v}\033[0m"
    done

    # Linha de base
    echo -e "\033[38;2;${border_color}m${bl}${horizontal_line}${br}\033[0m"
}

# ============================================================================
# SISTEMA DE ANIMA√á√ïES SUAVES
# ============================================================================

# Anima√ß√£o de carregamento
show_loading_animation() {
    local message="$1"
    local duration="${2:-3}"
    local chars=("‚óê" "‚óì" "‚óë" "‚óí")
    
    for ((i=0; i<duration*4; i++)); do
        local char="${chars[$((i % 4))]}"
        printf "\r\033[38;2;106;73;40m${char}\033[0m \033[38;2;190;173;162m$message\033[0m"
        sleep 0.25
    done
    printf "\r\033[38;2;106;73;40m‚úì\033[0m \033[38;2;190;173;162m$message\033[0m\n"
}

# Anima√ß√£o de digita√ß√£o
typewriter_effect() {
    local text="$1"
    local speed="${2:-0.05}"
    
    for ((i=0; i<${#text}; i++)); do
        echo -n "${text:$i:1}"
        sleep "$speed"
    done
    echo
}

# ============================================================================
# INTERFACES VISUAIS AVAN√áADAS
# ============================================================================

# Banner principal com estilo art√≠stico
show_fancy_banner() {
    clear
    local cols
    cols=$(get_terminal_dimensions | cut -d' ' -f1)

    # Definir largura do banner baseado no terminal
    local banner_width=$((cols - 4))
    ((banner_width < 50)) && banner_width=50
    ((banner_width > 100)) && banner_width=100

    # Textos do banner
    local title="üç´ AURORA v$SCRIPT_VERSION"
    local subtitle="Gerenciador de Temas Visuais Avan√ßado"
    local theme_line="Tema: Ganache (Chocolate) ‚ú¶"

    # Calcular larguras visuais CORRETAMENTE
    local title_visual_width
    title_visual_width=$(get_visual_width "$title")
    local subtitle_visual_width
    subtitle_visual_width=$(get_visual_width "$subtitle")
    local theme_visual_width
    theme_visual_width=$(get_visual_width "$theme_line")

    # Gerar linha horizontal (banner_width - 2 para os cantos)
    local h
    h=$(printf "‚ïê%.0s" $(seq 1 $((banner_width - 2))))

    # Largura interna para conte√∫do (sem as bordas verticais)
    local inner_width=$((banner_width - 2))

    # Topo
    echo -e "\033[38;2;106;73;40m‚îè${h}‚îì\033[0m"

    # T√≠tulo centralizado com padding correto
    local title_left_pad=$(( (inner_width - title_visual_width) / 2 ))
    local title_right_pad=$((inner_width - title_visual_width - title_left_pad))
    (( title_left_pad < 0 )) && title_left_pad=0
    (( title_right_pad < 0 )) && title_right_pad=0
    echo -e "\033[38;2;106;73;40m‚îÉ\033[0m\033[38;2;190;173;162m$(printf "%*s" "$title_left_pad" "")${title}$(printf "%*s" "$title_right_pad" "")\033[38;2;106;73;40m‚îÉ\033[0m"

    # Subt√≠tulo
    local subtitle_left_pad=$(( (inner_width - subtitle_visual_width) / 2 ))
    local subtitle_right_pad=$((inner_width - subtitle_visual_width - subtitle_left_pad))
    (( subtitle_left_pad < 0 )) && subtitle_left_pad=0
    (( subtitle_right_pad < 0 )) && subtitle_right_pad=0
    echo -e "\033[38;2;106;73;40m‚îÉ\033[0m\033[38;2;174;153;139m$(printf "%*s" "$subtitle_left_pad" "")${subtitle}$(printf "%*s" "$subtitle_right_pad" "")\033[38;2;106;73;40m‚îÉ\033[0m"

    # Linha do tema
    local theme_left_pad=$(( (inner_width - theme_visual_width) / 2 ))
    local theme_right_pad=$((inner_width - theme_visual_width - theme_left_pad))
    (( theme_left_pad < 0 )) && theme_left_pad=0
    (( theme_right_pad < 0 )) && theme_right_pad=0
    echo -e "\033[38;2;106;73;40m‚îÉ\033[0m\033[38;2;190;173;162m$(printf "%*s" "$theme_left_pad" "")${theme_line}$(printf "%*s" "$theme_right_pad" "")\033[38;2;106;73;40m‚îÉ\033[0m"

    # Base
    echo -e "\033[38;2;106;73;40m‚îó${h}‚îõ\033[0m"
    echo
}

# Interface de status com elementos visuais avan√ßados
show_advanced_status() {
    show_fancy_banner
    
    # Container principal
    local status_content="üìä STATUS DO SISTEMA\n\n"
    
    # Status do Starship com indicador visual
    if command -v starship &> /dev/null; then
        local starship_version=$(starship --version 2>/dev/null | head -1)
        status_content+=" ${STATUS[success]} Starship: Instalado ($starship_version)\n"
    else
        status_content+=" ${STATUS[error]} Starship: N√£o instalado\n"
    fi
    
    # Status do KMSCON
    if command -v kmscon &> /dev/null; then
        status_content+=" ${STATUS[success]} KMSCON: Instalado\n"
    else
        status_content+=" ${STATUS[error]} KMSCON: N√£o instalado\n"
    fi
    
    # Status da FiraCode
    if fc-list | grep -q "FiraCode"; then
        status_content+=" ${STATUS[success]} FiraCode Nerd Font: Instalada\n"
    else
        status_content+=" ${STATUS[error]} FiraCode Nerd Font: N√£o instalada\n"
    fi
    
    # Tema atual
    if [[ -f "$STARSHIP_CONFIG" ]]; then
        local current_theme=$(grep -oP 'background = "\K[^"]*' "$STARSHIP_CONFIG" 2>/dev/null || echo "Padr√£o")
        status_content+=" ${STATUS[info]} Tema Atual: $current_theme\n"
    else
        status_content+=" ${STATUS[info]} Tema Atual: Padr√£o do sistema\n"
    fi
    
    # Mostrar caixa de status
    create_fancy_box "STATUS DO SISTEMA" "$status_content" "light" "106;73;40" "190;173;162" "auto"
    
    echo
    show_quick_commands
}

# Interface de ajuda avan√ßada
show_advanced_help() {
    show_fancy_banner
    
    local help_content="üç´ Sistema de gerenciamento de temas visuais avan√ßado\n\n"
    help_content+="${DECORATIVE[star_filled]} COMANDOS DISPON√çVEIS:\n\n"
    help_content+=" ‚Ä¢ aurora install     ${ARROWS[right]} Instalar todas as depend√™ncias\n"
    help_content+=" ‚Ä¢ aurora apply <tema> ${ARROWS[right]} Aplicar tema espec√≠fico\n"
    help_content+=" ‚Ä¢ aurora preview <tema> ${ARROWS[right]} Visualizar tema sem aplicar\n"
    help_content+=" ‚Ä¢ aurora list        ${ARROWS[right]} Listar temas dispon√≠veis\n"
    help_content+=" ‚Ä¢ aurora status      ${ARROWS[right]} Mostrar status do sistema\n"
    help_content+=" ‚Ä¢ aurora help        ${ARROWS[right]} Mostrar esta ajuda\n\n"
    help_content+="${DECORATIVE[diamond_filled]} TEMAS DISPON√çVEIS:\n\n"
    help_content+=" ‚Ä¢ ganache_noir  ${ARROWS[right]} Modo escuro intenso\n"
    help_content+=" ‚Ä¢ ganache_lait  ${ARROWS[right]} Modo padr√£o equilibrado\n"
    help_content+=" ‚Ä¢ ganache_blanc ${ARROWS[right]} Modo claro elegante"
    
    create_fancy_box "AJUDA DO AURORA" "$help_content" "heavy" "106;73;40" "190;173;162" "auto"
}

# Lista de temas com preview visual
show_fancy_theme_list() {
    show_fancy_banner
    echo -e "\033[38;2;174;153;139müé® TEMAS DISPON√çVEIS\033[0m\n"
    
    if [[ ! -d "$THEME_DIR" ]]; then
        create_fancy_box "ERRO" "Diret√≥rio de temas n√£o encontrado. Execute 'aurora install' primeiro." "dotted" "176;58;36" "255;255;255" "auto"
        return 1
    fi
    
    local themes=("$THEME_DIR"/*.theme)
    local theme_count=0
    
    for theme_file in "${themes[@]}"; do
        if [[ -f "$theme_file" ]]; then
            local theme_name=$(basename "$theme_file" .theme)
            local theme_info=$(get_theme_preview "$theme_file")
            
            echo -e "\033[38;2;106;73;40m[${ARTISTIC[star_circle]}]\033[0m \033[38;2;190;173;162m$theme_name\033[0m"
            echo -e "     $theme_info"
            echo
            ((theme_count++))
        fi
    done
    
    if [[ $theme_count -eq 0 ]]; then
        create_fancy_box "ATEN√á√ÉO" "Nenhum tema encontrado. Execute 'aurora install' primeiro." "dotted" "191;144;0" "255;255;255" "auto"
    else
        echo -e "\033[38;2;106;73;40m${STATUS[success]} $theme_count tema(s) dispon√≠vel(is)\033[0m"
    fi
}

# Obter preview visual do tema
get_theme_preview() {
    local theme_file="$1"
    local bg_color=$(grep "^BG_COLOR=" "$theme_file" | cut -d'"' -f2)
    local fg_color=$(grep "^FG_COLOR=" "$theme_file" | cut -d'"' -f2)
    local accent_color=$(grep "^ACCENT=" "$theme_file" | cut -d'"' -f2)
    
    echo -e "Fundo: \033[38;2;$(hex_to_rgb "$bg_color")m${DECORATIVE[square_filled]}\033[0m $bg_color | Texto: \033[38;2;$(hex_to_rgb "$fg_color")m${DECORATIVE[circle_filled]}\033[0m $fg_color | Destaque: \033[38;2;$(hex_to_rgb "$accent_color")m${DECORATIVE[diamond_filled]}\033[0m $accent_color"
}

# ============================================================================
# FUN√á√ïES DE UTILIDADE
# ============================================================================

hex_to_rgb() {
    local hex="$1"
    hex=${hex#\#}
    local r=$((0x${hex:0:2}))
    local g=$((0x${hex:2:2}))
    local b=$((0x${hex:4:2}))
    echo "$r;$g;$b"
}

show_quick_commands() {
    local commands_content="‚ö° COMANDOS R√ÅPIDOS\n\n"
    commands_content+=" ${ARROWS[right]} Execute: aurora install    (instalar depend√™ncias)\n"
    commands_content+=" ${ARROWS[right]} Execute: aurora list      (ver temas dispon√≠veis)\n"
    commands_content+=" ${ARROWS[right]} Execute: aurora apply ganache_lait (aplicar tema padr√£o)\n\n"
    commands_content+="${ARTISTIC[sparkle]} Dica: Use 'aurora preview <tema>' para visualizar antes de aplicar"
    
    create_fancy_box "COMANDOS R√ÅPIDOS" "$commands_content" "light" "106;73;40" "174;153;139" "auto"
}

show_welcome_message() {
    show_fancy_banner
    
    local welcome_content="üç´ Bem-vindo ao sistema de gerenciamento de temas visuais\n\n"
    welcome_content+="Este sistema avan√ßado gerencia automaticamente a apar√™ncia do\n"
    welcome_content+="terminal kmscon e do prompt Starship usando a paleta de cores\n"
    welcome_content+="Ganache (inspirada em tons de chocolate).\n\n"
    welcome_content+="${ARTISTIC[sparkle]} Recursos especiais:\n"
    welcome_content+=" ‚Ä¢ Interface responsiva com s√≠mbolos especiais\n"
    welcome_content+=" ‚Ä¢ Anima√ß√µes suaves e transi√ß√µes elegantes\n"
    welcome_content+=" ‚Ä¢ Temas adaptativos e layouts flex√≠veis\n"
    welcome_content+=" ‚Ä¢ Suporte completo para UTF-8\n\n"
    welcome_content+="${DECORATIVE[star_filled]} Para come√ßar:\n"
    welcome_content+=" ‚Ä¢ Execute 'aurora install' para instalar depend√™ncias\n"
    welcome_content+=" ‚Ä¢ Execute 'aurora list' para ver temas dispon√≠veis\n"
    welcome_content+=" ‚Ä¢ Execute 'aurora help' para ver todos os comandos"
    
    create_fancy_box "BEM-VINDO AO AURORA" "$welcome_content" "heavy" "106;73;40" "190;173;162" "auto"
}

# ============================================================================
# FUN√á√ïES DE MENSAGEM VISUAL
# ============================================================================

show_success() {
    local message="$1"
    create_fancy_box "SUCESSO" "${STATUS[success]} $message" "light" "38;160;72" "255;255;255" "auto"
}

show_error() {
    local message="$1"
    create_fancy_box "ERRO" "${STATUS[error]} $message" "dotted" "176;58;36" "255;255;255" "auto"
}

show_info() {
    local message="$1"
    echo -e "üç´ \033[38;2;174;153;139m$message\033[0m"
}

show_warning() {
    local message="$1"
    create_fancy_box "AVISO" "${STATUS[warning]} $message" "light" "191;144;0" "255;255;255" "auto"
}

# ============================================================================
# FUN√á√ïES DE INSTALA√á√ÉO (PRESERVADAS DA VERS√ÉO ANTERIOR)
# ============================================================================

install_dependencies() {
    show_info "Iniciando instala√ß√£o das depend√™ncias do AURORA..."
    show_loading_animation "Instalando depend√™ncias" 3
    
    # Verificar privil√©gios root
    if [[ $EUID -ne 0 ]]; then
        show_error "Este script deve ser executado como root"
        exit 1
    fi
    
    # Atualizar reposit√≥rios
    show_info "Atualizando reposit√≥rios do sistema..."
    apt update -qq
    
    # Instalar pacotes b√°sicos
    local packages=("kmscon" "curl" "fontconfig" "git")
    for package in "${packages[@]}"; do
        show_info "Instalando $package..."
        if ! dpkg -l | grep -q "^ii  $package "; then
            apt install -y "$package"
            show_success "$package instalado com sucesso"
        else
            show_success "$package j√° est√° instalado"
        fi
    done
    
    # Instalar Starship
    show_info "Instalando Starship..."
    if ! command -v starship &> /dev/null; then
        sh -c "$(curl -fsSL https://starship.rs/install.sh)" -- --bin-dir /usr/local/bin
        show_success "Starship instalado com sucesso"
    else
        show_success "Starship j√° est√° instalado"
    fi
    
    # Instalar FiraCode Nerd Font
    install_nerd_font
    
    # Configurar kmscon
    configure_kmscon
    
    show_success "Todas as depend√™ncias foram instaladas com sucesso!"
}

install_nerd_font() {
    show_info "Verificando FiraCode Nerd Font..."
    
    local font_dir="/usr/local/share/fonts"
    local font_name="FiraCodeNerdFont"
    local font_file="$font_dir/$font_name.ttf"
    
    if fc-list | grep -q "FiraCode"; then
        show_success "FiraCode j√° est√° instalada"
        return 0
    fi
    
    show_info "Baixando FiraCode Nerd Font..."
    mkdir -p "$font_dir"
    
    local font_url="https://github.com/ryanoasis/nerd-fonts/releases/latest/download/FiraCode.zip"
    
    local temp_dir=$(mktemp -d)
    cd "$temp_dir"
    
    if curl -fsSL "$font_url" -o "FiraCode.zip"; then
        unzip -q "FiraCode.zip"
        cp "FiraCodeNerdFont-Regular.ttf" "$font_file"
        fc-cache -fv
        rm -rf "$temp_dir"
        show_success "FiraCode Nerd Font instalada com sucesso"
    else
        if curl -fsSL "https://github.com/ryanoasis/nerd-fonts/raw/master/patched-fonts/FiraCode/Regular/complete/Fira%20Code%20Regular%20Nerd%20Font%20Complete.ttf" -o "$font_file"; then
            fc-cache -fv
            show_success "FiraCode Nerd Font instalada (fallback)"
        else
            rm -rf "$temp_dir"
            show_warning "Falha ao baixar FiraCode. Usando fonte padr√£o do sistema."
        fi
    fi
}

configure_kmscon() {
    show_info "Configurando kmscon..."
    
    mkdir -p "/etc/kmscon"
    
    cat > "$KMSCON_CONF" << 'EOF'
# Configura√ß√£o do KMSCON para AURORA
font-name=FiraCode Nerd Font
font-size=14
color-truecolor=true
color-0=15,15,15
color-1=175,0,32
color-2=38,160,72
color-3=185,118,29
color-4=33,113,181
color-5=137,62,178
color-6=40,142,185
color-7=170,170,170
color-8=85,85,85
color-9=255,85,85
color-10=85,255,85
color-11=255,255,85
color-12=85,85,255
color-13=255,85,255
color-14=85,255,255
color-15=255,255,255
console=true
font-force-scalable=true
xkb-layout=us
xkb-variant=nodeadkeys
xkb-options=caps:escape
EOF

    show_success "KMSCON configurado com sucesso"
}

# ============================================================================
# FUN√á√ïES DE TEMA (PRESERVADAS DA VERS√ÉO ANTERIOR)
# ============================================================================

generate_theme_files() {
    show_info "Gerando arquivos de tema padr√£o..."
    
    mkdir -p "$THEME_DIR"
    
    cat > "$THEME_DIR/ganache_noir.theme" << 'EOF'
# Tema Ganache Noir - Modo Escuro Intenso
BG_COLOR="#0b0704"
FG_COLOR="#beada2"
ACCENT="#6a4928"
EOF

    cat > "$THEME_DIR/ganache_lait.theme" << 'EOF'
# Tema Ganache Lait - Modo Padr√£o Equilibrado
BG_COLOR="#2a1d10"
FG_COLOR="#ded6d1"
ACCENT="#ae998b"
EOF

    cat > "$THEME_DIR/ganache_blanc.theme" << 'EOF'
# Tema Ganache Blanc - Modo Claro Elegante
BG_COLOR="#efebe8"
FG_COLOR="#352514"
ACCENT="#5f4224"
EOF

    show_success "Arquivos de tema gerados com sucesso em $THEME_DIR"
}

apply_theme() {
    local theme_name="$1"
    local theme_file="$THEME_DIR/${theme_name}.theme"
    
    show_fancy_banner
    create_fancy_box "APLICANDO TEMA" "${ARTISTIC[sparkle]} Aplicando tema: $theme_name" "light" "106;73;40" "190;173;162" "auto"
    
    if [[ ! -f "$theme_file" ]]; then
        show_error "Tema '$theme_name' n√£o encontrado"
        echo "Use 'aurora list' para ver temas dispon√≠veis"
        exit 1
    fi
    
    source "$theme_file"
    
    # Aplicar configura√ß√µes (vers√£o simplificada)
    mkdir -p "$(dirname "$STARSHIP_CONFIG")"
    cat > "$STARSHIP_CONFIG" << EOF
# Configura√ß√£o do Starship - Tema AURORA ($theme_name)
[hostname]
format = '[\$name]($ACCENT) on '
style = '$FG_COLOR'

[character]
success_symbol = '[$ARROWS[right]]($ACCENT)'
error_symbol = '[$ARROWS[left]]($ACCENT)'
EOF
    
    show_success "Tema '$theme_name' aplicado com sucesso!"
}

preview_theme() {
    local theme_name="$1"
    local theme_file="$THEME_DIR/${theme_name}.theme"
    
    show_fancy_banner
    create_fancy_box "PREVIEW DO TEMA" "üç´ Visualizando tema: $theme_name (tempor√°rio, 5 segundos)" "heavy" "106;73;40" "190;173;162" "auto"
    
    if [[ ! -f "$theme_file" ]]; then
        show_error "Tema '$theme_name' n√£o encontrado"
        exit 1
    fi
    
    source "$theme_file"
    
    # Preview visual simplificado
    local preview_content="üé® PREVIEW DO TEMA: $theme_name\n\n"
    preview_content+="Hostname: ${ARTISTIC[star_circle]} Aurora-Server on /dev/pts/0\n\n"
    preview_content+="~/projetos/aurora main $ARROWS[right] git status\n"
    preview_content+="On branch main\n"
    preview_content+="Your branch is up to date with 'origin/main'.\n\n"
    preview_content+="nothing to commit, working tree clean\n"
    preview_content+="üç´ AURORA $(date +%H:%M:%S)\n\n"
    preview_content+="üé® Paleta de Cores:\n"
    preview_content+=" Fundo: $BG_COLOR | Texto: $FG_COLOR | Destaque: $ACCENT"
    
    create_fancy_box "PREVIEW" "$preview_content" "light" "$(hex_to_rgb "$ACCENT")" "$(hex_to_rgb "$FG_COLOR")" "auto"
    
    show_info "Preview ativo por 5 segundos..."
    sleep 5
    
    show_success "Preview finalizado - cores revertidas"
}

# ============================================================================
# FUN√á√ÉO PRINCIPAL
# ============================================================================

main() {
    case "${1:-}" in
        "install")
            generate_theme_files
            install_dependencies
            ;;
        "apply")
            if [[ -z "${2:-}" ]]; then
                show_error "Uso: aurora apply <tema>"
                echo "Use 'aurora list' para ver temas dispon√≠veis"
                exit 1
            fi
            apply_theme "$2"
            ;;
        "preview")
            if [[ -z "${2:-}" ]]; then
                show_error "Uso: aurora preview <tema>"
                echo "Use 'aurora list' para ver temas dispon√≠veis"
                exit 1
            fi
            preview_theme "$2"
            ;;
        "list")
            show_fancy_theme_list
            ;;
        "status")
            show_advanced_status
            ;;
        "help"|"--help"|"-h")
            show_advanced_help
            ;;
        "")
            show_welcome_message
            ;;
        *)
            show_error "Comando desconhecido: $1"
            echo "Use 'aurora help' para ver comandos dispon√≠veis"
            exit 1
            ;;
    esac
}

# ============================================================================
# EXECU√á√ÉO
# ============================================================================

main "$@"